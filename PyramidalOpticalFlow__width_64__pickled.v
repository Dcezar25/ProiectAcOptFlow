//-------------------------------------------------------------------------
// PyramidalOpticalFlow__width_64.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL Component Downsampler Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\downsampler.py

module Downsampler__img_width_64
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [7:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output logic [7:0] send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  logic [0:0] col_odd;
  logic [7:0] line_buffer [0:63];
  logic [5:0] ptr;
  logic [0:0] row_odd;
  logic [8:0] __tmpvar__output_logic_avg;

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\downsampler.py:36
  // @update
  // def output_logic():
  //     s.recv.rdy @= s.send.rdy
  //     
  //     avg = (zext(s.recv.msg, 9) + zext(s.line_buffer[s.ptr], 9)) >> 1
  //     s.send.msg @= avg[0:8]
  //     
  //     s.send.val @= s.recv.val & s.row_odd & s.col_odd
  
  always_comb begin : output_logic
    recv__rdy = send__rdy;
    __tmpvar__output_logic_avg = ( { { 1 { 1'b0 } }, recv__msg } + { { 1 { 1'b0 } }, line_buffer[ptr] } ) >> 1'd1;
    send__msg = __tmpvar__output_logic_avg[4'd7:4'd0];
    send__val = ( recv__val & row_odd ) & col_odd;
  end

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\downsampler.py:20
  // @update_ff
  // def seq_logic():
  //     if s.reset:
  //         s.ptr <<= 0
  //         s.row_odd <<= 0
  //         s.col_odd <<= 0
  //     elif s.recv.val & s.send.rdy:
  //         if s.ptr == s.img_width - 1:
  //             s.ptr <<= 0
  //             s.row_odd <<= ~s.row_odd
  //         else:
  //             s.ptr <<= s.ptr + 1
  //         
  //         s.col_odd <<= ~s.col_odd
  //         s.line_buffer[s.ptr] <<= s.recv.msg
  
  always_ff @(posedge clk) begin : seq_logic
    if ( reset ) begin
      ptr <= 6'd0;
      row_odd <= 1'd0;
      col_odd <= 1'd0;
    end
    else if ( recv__val & send__rdy ) begin
      if ( ptr == ( 6'd64 - 6'd1 ) ) begin
        ptr <= 6'd0;
        row_odd <= ~row_odd;
      end
      else
        ptr <= ptr + 6'd1;
      col_odd <= ~col_odd;
      line_buffer[ptr] <= recv__msg;
    end
  end

endmodule


// PyMTL Component GradientUnit Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\gradient_unit.py

module GradientUnit_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [23:0] recv_col__msg  ,
  output logic [0:0] recv_col__rdy  ,
  input logic [0:0] recv_col__val  ,
  input logic [7:0] recv_prev__msg  ,
  output logic [0:0] recv_prev__rdy  ,
  input logic [0:0] recv_prev__val  ,
  output logic [47:0] send_grad__msg  ,
  input logic [0:0] send_grad__rdy  ,
  output logic [0:0] send_grad__val  
);
  logic [23:0] col_0;
  logic [23:0] col_1;
  logic [23:0] col_2;
  logic [15:0] prev_frame_pixel;
  logic [15:0] __tmpvar__calculation_logic_p00;
  logic [15:0] __tmpvar__calculation_logic_p10;
  logic [15:0] __tmpvar__calculation_logic_p20;
  logic [15:0] __tmpvar__calculation_logic_p01;
  logic [15:0] __tmpvar__calculation_logic_p11;
  logic [15:0] __tmpvar__calculation_logic_p21;
  logic [15:0] __tmpvar__calculation_logic_p02;
  logic [15:0] __tmpvar__calculation_logic_p12;
  logic [15:0] __tmpvar__calculation_logic_p22;
  logic [15:0] __tmpvar__calculation_logic_pos_term_x;
  logic [15:0] __tmpvar__calculation_logic_neg_term_x;
  logic [15:0] __tmpvar__calculation_logic_ix_val;
  logic [15:0] __tmpvar__calculation_logic_pos_term_y;
  logic [15:0] __tmpvar__calculation_logic_neg_term_y;
  logic [15:0] __tmpvar__calculation_logic_iy_val;
  logic [15:0] __tmpvar__calculation_logic_it_val;

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\gradient_unit.py:39
  // @update
  // def calculation_logic():
  //     # Ready logic
  //     s.recv_col.rdy  @= s.send_grad.rdy
  //     s.recv_prev.rdy @= s.send_grad.rdy
  //     
  //     # 1. Extragem pixelii din fereastra 3x3
  //     # Coloana Stanga (0)
  //     p00 = zext(s.col_0[16:24], 16) # Sus-Stanga
  //     p10 = zext(s.col_0[ 8:16], 16) # Mij-Stanga
  //     p20 = zext(s.col_0[ 0: 8], 16) # Jos-Stanga
  //     
  //     # Coloana Mijloc (1)
  //     p01 = zext(s.col_1[16:24], 16) # Sus-Mij
  //     p11 = zext(s.col_1[ 8:16], 16) # Centru
  //     p21 = zext(s.col_1[ 0: 8], 16) # Jos-Mij
  //     
  //     # Coloana Dreapta (2)
  //     p02 = zext(s.col_2[16:24], 16) # Sus-Dreapta
  //     p12 = zext(s.col_2[ 8:16], 16) # Mij-Dreapta
  //     p22 = zext(s.col_2[ 0: 8], 16) # Jos-Dreapta
  //     
  //     # 2. Calcul Sobel X
  //     # Ix = (p02 + 2*p12 + p22) - (p00 + 2*p10 + p20)
  //     pos_term_x = p02 + (p12 << 1) + p22
  //     neg_term_x = p00 + (p10 << 1) + p20
  //     ix_val = pos_term_x - neg_term_x
  //     
  //     # 3. Calcul Sobel Y
  //     # Iy = (p20 + 2*p21 + p22) - (p00 + 2*p01 + p02)
  //     pos_term_y = p20 + (p21 << 1) + p22
  //     neg_term_y = p00 + (p01 << 1) + p02
  //     iy_val = pos_term_y - neg_term_y
  //     
  //     # 4. Calcul Derivata Temporala (It)
  //     it_val = p11 - s.prev_frame_pixel
  //     
  //     # 5. Output [It, Iy, Ix]
  //     s.send_grad.msg @= concat( it_val, iy_val, ix_val )
  //     
  //     # Valid logic
  //     s.send_grad.val @= s.recv_col.val & s.recv_prev.val
  
  always_comb begin : calculation_logic
    recv_col__rdy = send_grad__rdy;
    recv_prev__rdy = send_grad__rdy;
    __tmpvar__calculation_logic_p00 = { { 8 { 1'b0 } }, col_0[5'd23:5'd16] };
    __tmpvar__calculation_logic_p10 = { { 8 { 1'b0 } }, col_0[5'd15:5'd8] };
    __tmpvar__calculation_logic_p20 = { { 8 { 1'b0 } }, col_0[5'd7:5'd0] };
    __tmpvar__calculation_logic_p01 = { { 8 { 1'b0 } }, col_1[5'd23:5'd16] };
    __tmpvar__calculation_logic_p11 = { { 8 { 1'b0 } }, col_1[5'd15:5'd8] };
    __tmpvar__calculation_logic_p21 = { { 8 { 1'b0 } }, col_1[5'd7:5'd0] };
    __tmpvar__calculation_logic_p02 = { { 8 { 1'b0 } }, col_2[5'd23:5'd16] };
    __tmpvar__calculation_logic_p12 = { { 8 { 1'b0 } }, col_2[5'd15:5'd8] };
    __tmpvar__calculation_logic_p22 = { { 8 { 1'b0 } }, col_2[5'd7:5'd0] };
    __tmpvar__calculation_logic_pos_term_x = ( __tmpvar__calculation_logic_p02 + ( __tmpvar__calculation_logic_p12 << 1'd1 ) ) + __tmpvar__calculation_logic_p22;
    __tmpvar__calculation_logic_neg_term_x = ( __tmpvar__calculation_logic_p00 + ( __tmpvar__calculation_logic_p10 << 1'd1 ) ) + __tmpvar__calculation_logic_p20;
    __tmpvar__calculation_logic_ix_val = __tmpvar__calculation_logic_pos_term_x - __tmpvar__calculation_logic_neg_term_x;
    __tmpvar__calculation_logic_pos_term_y = ( __tmpvar__calculation_logic_p20 + ( __tmpvar__calculation_logic_p21 << 1'd1 ) ) + __tmpvar__calculation_logic_p22;
    __tmpvar__calculation_logic_neg_term_y = ( __tmpvar__calculation_logic_p00 + ( __tmpvar__calculation_logic_p01 << 1'd1 ) ) + __tmpvar__calculation_logic_p02;
    __tmpvar__calculation_logic_iy_val = __tmpvar__calculation_logic_pos_term_y - __tmpvar__calculation_logic_neg_term_y;
    __tmpvar__calculation_logic_it_val = __tmpvar__calculation_logic_p11 - prev_frame_pixel;
    send_grad__msg = { __tmpvar__calculation_logic_it_val, __tmpvar__calculation_logic_iy_val, __tmpvar__calculation_logic_ix_val };
    send_grad__val = recv_col__val & recv_prev__val;
  end

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\gradient_unit.py:23
  // @update_ff
  // def shift_window_logic():
  //     if s.reset:
  //         s.col_0 <<= 0
  //         s.col_1 <<= 0
  //         s.col_2 <<= 0
  //     # FIX: Folosim & in loc de and
  //     elif s.recv_col.val & s.send_grad.rdy:
  //         # Shiftam coloanele spre stanga
  //         s.col_0 <<= s.col_1
  //         s.col_1 <<= s.col_2
  //         s.col_2 <<= s.recv_col.msg
  //         
  //         # Memoram pixelul prev
  //         s.prev_frame_pixel <<= zext(s.recv_prev.msg, 16)
  
  always_ff @(posedge clk) begin : shift_window_logic
    if ( reset ) begin
      col_0 <= 24'd0;
      col_1 <= 24'd0;
      col_2 <= 24'd0;
    end
    else if ( recv_col__val & send_grad__rdy ) begin
      col_0 <= col_1;
      col_1 <= col_2;
      col_2 <= recv_col__msg;
      prev_frame_pixel <= { { 8 { 1'b0 } }, recv_prev__msg };
    end
  end

endmodule


// PyMTL Component HSCore Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\hs_core.py

module HSCore__alpha_20
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [47:0] recv_grads__msg  ,
  output logic [0:0] recv_grads__rdy  ,
  input logic [0:0] recv_grads__val  ,
  input logic [63:0] recv_uv__msg  ,
  output logic [0:0] recv_uv__rdy  ,
  input logic [0:0] recv_uv__val  ,
  output logic [63:0] send_uv__msg  ,
  input logic [0:0] send_uv__rdy  ,
  output logic [0:0] send_uv__val  
);
  localparam logic [3:0] __const__FP_SHIFT_at_math_logic  = 4'd12;
  logic [31:0] ALPHA_SQ;
  logic [31:0] dbg_denom;
  logic [31:0] denom_safe;
  logic [15:0] __tmpvar__math_logic_raw_ix;
  logic [15:0] __tmpvar__math_logic_raw_iy;
  logic [15:0] __tmpvar__math_logic_raw_it;
  logic [31:0] __tmpvar__math_logic_raw_u_init;
  logic [31:0] __tmpvar__math_logic_raw_v_init;
  logic [31:0] __tmpvar__math_logic_ix;
  logic [31:0] __tmpvar__math_logic_iy;
  logic [31:0] __tmpvar__math_logic_it;
  logic [31:0] __tmpvar__math_logic_u_init;
  logic [31:0] __tmpvar__math_logic_v_init;
  logic [31:0] __tmpvar__math_logic_denom;
  logic [31:0] __tmpvar__math_logic_term_it;
  logic [31:0] __tmpvar__math_logic_data_term;
  logic [31:0] __tmpvar__math_logic_num_u;
  logic [31:0] __tmpvar__math_logic_update_u;
  logic [31:0] __tmpvar__math_logic_num_v;
  logic [31:0] __tmpvar__math_logic_update_v;
  logic [31:0] __tmpvar__math_logic_u_new;
  logic [31:0] __tmpvar__math_logic_v_new;

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\hs_core.py:20
  // @update
  // def math_logic():
  //     s.recv_grads.rdy @= s.send_uv.rdy
  //     s.recv_uv.rdy    @= s.send_uv.rdy
  //     
  //     # 1. Extragere Valori Raw (Bits)
  //     raw_ix = s.recv_grads.msg[0:16]
  //     raw_iy = s.recv_grads.msg[16:32]
  //     raw_it = s.recv_grads.msg[32:48]
  //     
  //     raw_u_init = s.recv_uv.msg[0:32]
  //     raw_v_init = s.recv_uv.msg[32:64]
  //     
  //     # 2. Extensie de Semn
  //     ix = sext(raw_ix, 32)
  //     iy = sext(raw_iy, 32)
  //     it = sext(raw_it, 32)
  //     
  //     u_init = raw_u_init
  //     v_init = raw_v_init
  //     
  //     # 3. Calcule Matematice
  //     denom = s.ALPHA_SQ + (ix * ix) + (iy * iy)
  //     
  //     # Protectie la impartire prin zero (Hardware Mux Logic)
  //     if denom == 0: 
  //         s.denom_safe @= 1
  //     else:
  //         s.denom_safe @= denom
  //     
  //     s.dbg_denom @= s.denom_safe
  //     
  //     # Data Term
  //     term_it = it << FP_SHIFT
  //     data_term = (ix * u_init) + (iy * v_init) + term_it
  //     
  //     # Calcul Update
  //     # Folosim denom_safe care este Wire acum
  //     num_u = ix * data_term
  //     update_u = num_u / s.denom_safe
  //     
  //     num_v = iy * data_term
  //     update_v = num_v / s.denom_safe
  //     
  //     # Rezultat Final
  //     u_new = u_init - update_u
  //     v_new = v_init - update_v
  //     
  //     # Impachetare
  //     s.send_uv.msg @= concat( v_new, u_new )
  //     s.send_uv.val @= s.recv_grads.val & s.recv_uv.val
  
  always_comb begin : math_logic
    recv_grads__rdy = send_uv__rdy;
    recv_uv__rdy = send_uv__rdy;
    __tmpvar__math_logic_raw_ix = recv_grads__msg[6'd15:6'd0];
    __tmpvar__math_logic_raw_iy = recv_grads__msg[6'd31:6'd16];
    __tmpvar__math_logic_raw_it = recv_grads__msg[6'd47:6'd32];
    __tmpvar__math_logic_raw_u_init = recv_uv__msg[6'd31:6'd0];
    __tmpvar__math_logic_raw_v_init = recv_uv__msg[6'd63:6'd32];
    __tmpvar__math_logic_ix = { { 16 { __tmpvar__math_logic_raw_ix[15] } }, __tmpvar__math_logic_raw_ix };
    __tmpvar__math_logic_iy = { { 16 { __tmpvar__math_logic_raw_iy[15] } }, __tmpvar__math_logic_raw_iy };
    __tmpvar__math_logic_it = { { 16 { __tmpvar__math_logic_raw_it[15] } }, __tmpvar__math_logic_raw_it };
    __tmpvar__math_logic_u_init = __tmpvar__math_logic_raw_u_init;
    __tmpvar__math_logic_v_init = __tmpvar__math_logic_raw_v_init;
    __tmpvar__math_logic_denom = ( ALPHA_SQ + ( __tmpvar__math_logic_ix * __tmpvar__math_logic_ix ) ) + ( __tmpvar__math_logic_iy * __tmpvar__math_logic_iy );
    if ( __tmpvar__math_logic_denom == 32'd0 ) begin
      denom_safe = 32'd1;
    end
    else
      denom_safe = __tmpvar__math_logic_denom;
    dbg_denom = denom_safe;
    __tmpvar__math_logic_term_it = __tmpvar__math_logic_it << 4'( __const__FP_SHIFT_at_math_logic );
    __tmpvar__math_logic_data_term = ( ( __tmpvar__math_logic_ix * __tmpvar__math_logic_u_init ) + ( __tmpvar__math_logic_iy * __tmpvar__math_logic_v_init ) ) + __tmpvar__math_logic_term_it;
    __tmpvar__math_logic_num_u = __tmpvar__math_logic_ix * __tmpvar__math_logic_data_term;
    __tmpvar__math_logic_update_u = __tmpvar__math_logic_num_u / denom_safe;
    __tmpvar__math_logic_num_v = __tmpvar__math_logic_iy * __tmpvar__math_logic_data_term;
    __tmpvar__math_logic_update_v = __tmpvar__math_logic_num_v / denom_safe;
    __tmpvar__math_logic_u_new = __tmpvar__math_logic_u_init - __tmpvar__math_logic_update_u;
    __tmpvar__math_logic_v_new = __tmpvar__math_logic_v_init - __tmpvar__math_logic_update_v;
    send_uv__msg = { __tmpvar__math_logic_v_new, __tmpvar__math_logic_u_new };
    send_uv__val = recv_grads__val & recv_uv__val;
  end

  assign ALPHA_SQ = 32'd400;

endmodule


// PyMTL Component LineBuffer Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\line_buffer.py

module LineBuffer__data_width_8__img_width_32
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [7:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output logic [23:0] send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  logic [31:0] count;
  logic [7:0] line_mem_1 [0:31];
  logic [7:0] line_mem_2 [0:31];
  logic [4:0] ptr;
  logic [7:0] val_popped;
  logic [4:0] __tmpvar__sequential_logic_idx;
  logic [4:0] __tmpvar__output_logic_r_idx;
  logic [7:0] __tmpvar__output_logic_p0;
  logic [7:0] __tmpvar__output_logic_p1;
  logic [7:0] __tmpvar__output_logic_p2;

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\line_buffer.py:54
  // @update
  // def output_logic():
  //     s.recv.rdy @= s.send.rdy
  //     
  //     # CALCUL INDEX CITIRE
  //     # FIX: Eliminam int()
  //     # Logica de wrap-around pentru pointer circular
  //     r_idx = s.ptr
  //     if s.ptr == 0:
  //         r_idx = s.IMG_WIDTH - 1
  //     else:
  //         r_idx = s.ptr - 1
  //     
  //     # CONSTRUIRE FEREASTRA
  //     p0 = s.recv.msg
  //     p1 = s.line_mem_2[r_idx]
  //     p2 = s.val_popped
  //     
  //     s.send.msg @= concat( p2, p1, p0 )
  //     
  //     # Valid dupa ce avem 2 linii pline
  //     # Folosim & in loc de and
  //     s.send.val @= s.recv.val & (s.count >= (s.IMG_WIDTH * 2))
  
  always_comb begin : output_logic
    recv__rdy = send__rdy;
    __tmpvar__output_logic_r_idx = ptr;
    if ( ptr == 5'd0 ) begin
      __tmpvar__output_logic_r_idx = 6'd32 - 6'd1;
    end
    else
      __tmpvar__output_logic_r_idx = ptr - 5'd1;
    __tmpvar__output_logic_p0 = recv__msg;
    __tmpvar__output_logic_p1 = line_mem_2[__tmpvar__output_logic_r_idx];
    __tmpvar__output_logic_p2 = val_popped;
    send__msg = { __tmpvar__output_logic_p2, __tmpvar__output_logic_p1, __tmpvar__output_logic_p0 };
    send__val = recv__val & ( count >= ( 32'd32 * 32'd2 ) );
  end

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\line_buffer.py:28
  // @update_ff
  // def sequential_logic():
  //     if s.reset:
  //         s.ptr <<= 0
  //         s.count <<= 0
  //         s.val_popped <<= 0
  //     # FIX: Folosim & in loc de and
  //     elif s.recv.val & s.send.rdy:
  //         # FIX: Eliminam int(). Folosim semnalul direct.
  //         idx = s.ptr
  //         
  //         # 1. SALVAM VECHILE VALORI
  //         s.val_popped <<= s.line_mem_2[idx]
  //         
  //         # 2. SHIFTAM DATELE
  //         s.line_mem_2[idx] <<= s.line_mem_1[idx]
  //         s.line_mem_1[idx] <<= s.recv.msg
  //         
  //         # 3. ACTUALIZAM POINTERII
  //         if s.ptr == s.IMG_WIDTH - 1:
  //             s.ptr <<= 0
  //         else:
  //             s.ptr <<= s.ptr + 1
  //         
  //         s.count <<= s.count + 1
  
  always_ff @(posedge clk) begin : sequential_logic
    if ( reset ) begin
      ptr <= 5'd0;
      count <= 32'd0;
      val_popped <= 8'd0;
    end
    else if ( recv__val & send__rdy ) begin
      __tmpvar__sequential_logic_idx = ptr;
      val_popped <= line_mem_2[__tmpvar__sequential_logic_idx];
      line_mem_2[__tmpvar__sequential_logic_idx] <= line_mem_1[__tmpvar__sequential_logic_idx];
      line_mem_1[__tmpvar__sequential_logic_idx] <= recv__msg;
      if ( ptr == ( 5'd32 - 5'd1 ) ) begin
        ptr <= 5'd0;
      end
      else
        ptr <= ptr + 5'd1;
      count <= count + 32'd1;
    end
  end

endmodule


// PyMTL Component OpticalFlowTop Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\optical_flow_top.py

module OpticalFlowTop__img_width_32__alpha_20
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [7:0] recv_curr__msg  ,
  output logic [0:0] recv_curr__rdy  ,
  input logic [0:0] recv_curr__val  ,
  input logic [63:0] recv_init_uv__msg  ,
  output logic [0:0] recv_init_uv__rdy  ,
  input logic [0:0] recv_init_uv__val  ,
  input logic [7:0] recv_prev__msg  ,
  output logic [0:0] recv_prev__rdy  ,
  input logic [0:0] recv_prev__val  ,
  output logic [63:0] send_uv__msg  ,
  input logic [0:0] send_uv__rdy  ,
  output logic [0:0] send_uv__val  
);
  //-------------------------------------------------------------
  // Component grad_unit
  //-------------------------------------------------------------

  logic [0:0] grad_unit__clk;
  logic [0:0] grad_unit__reset;
  logic [23:0] grad_unit__recv_col__msg;
  logic [0:0] grad_unit__recv_col__rdy;
  logic [0:0] grad_unit__recv_col__val;
  logic [7:0] grad_unit__recv_prev__msg;
  logic [0:0] grad_unit__recv_prev__rdy;
  logic [0:0] grad_unit__recv_prev__val;
  logic [47:0] grad_unit__send_grad__msg;
  logic [0:0] grad_unit__send_grad__rdy;
  logic [0:0] grad_unit__send_grad__val;

  GradientUnit_noparam grad_unit
  (
    .clk( grad_unit__clk ),
    .reset( grad_unit__reset ),
    .recv_col__msg( grad_unit__recv_col__msg ),
    .recv_col__rdy( grad_unit__recv_col__rdy ),
    .recv_col__val( grad_unit__recv_col__val ),
    .recv_prev__msg( grad_unit__recv_prev__msg ),
    .recv_prev__rdy( grad_unit__recv_prev__rdy ),
    .recv_prev__val( grad_unit__recv_prev__val ),
    .send_grad__msg( grad_unit__send_grad__msg ),
    .send_grad__rdy( grad_unit__send_grad__rdy ),
    .send_grad__val( grad_unit__send_grad__val )
  );

  //-------------------------------------------------------------
  // End of component grad_unit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component hs_core
  //-------------------------------------------------------------

  logic [0:0] hs_core__clk;
  logic [0:0] hs_core__reset;
  logic [47:0] hs_core__recv_grads__msg;
  logic [0:0] hs_core__recv_grads__rdy;
  logic [0:0] hs_core__recv_grads__val;
  logic [63:0] hs_core__recv_uv__msg;
  logic [0:0] hs_core__recv_uv__rdy;
  logic [0:0] hs_core__recv_uv__val;
  logic [63:0] hs_core__send_uv__msg;
  logic [0:0] hs_core__send_uv__rdy;
  logic [0:0] hs_core__send_uv__val;

  HSCore__alpha_20 hs_core
  (
    .clk( hs_core__clk ),
    .reset( hs_core__reset ),
    .recv_grads__msg( hs_core__recv_grads__msg ),
    .recv_grads__rdy( hs_core__recv_grads__rdy ),
    .recv_grads__val( hs_core__recv_grads__val ),
    .recv_uv__msg( hs_core__recv_uv__msg ),
    .recv_uv__rdy( hs_core__recv_uv__rdy ),
    .recv_uv__val( hs_core__recv_uv__val ),
    .send_uv__msg( hs_core__send_uv__msg ),
    .send_uv__rdy( hs_core__send_uv__rdy ),
    .send_uv__val( hs_core__send_uv__val )
  );

  //-------------------------------------------------------------
  // End of component hs_core
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component line_buffer
  //-------------------------------------------------------------

  logic [0:0] line_buffer__clk;
  logic [0:0] line_buffer__reset;
  logic [7:0] line_buffer__recv__msg;
  logic [0:0] line_buffer__recv__rdy;
  logic [0:0] line_buffer__recv__val;
  logic [23:0] line_buffer__send__msg;
  logic [0:0] line_buffer__send__rdy;
  logic [0:0] line_buffer__send__val;

  LineBuffer__data_width_8__img_width_32 line_buffer
  (
    .clk( line_buffer__clk ),
    .reset( line_buffer__reset ),
    .recv__msg( line_buffer__recv__msg ),
    .recv__rdy( line_buffer__recv__rdy ),
    .recv__val( line_buffer__recv__val ),
    .send__msg( line_buffer__send__msg ),
    .send__rdy( line_buffer__send__rdy ),
    .send__val( line_buffer__send__val )
  );

  //-------------------------------------------------------------
  // End of component line_buffer
  //-------------------------------------------------------------

  assign line_buffer__clk = clk;
  assign line_buffer__reset = reset;
  assign grad_unit__clk = clk;
  assign grad_unit__reset = reset;
  assign hs_core__clk = clk;
  assign hs_core__reset = reset;
  assign line_buffer__recv__msg = recv_curr__msg;
  assign recv_curr__rdy = line_buffer__recv__rdy;
  assign line_buffer__recv__val = recv_curr__val;
  assign grad_unit__recv_col__msg = line_buffer__send__msg;
  assign line_buffer__send__rdy = grad_unit__recv_col__rdy;
  assign grad_unit__recv_col__val = line_buffer__send__val;
  assign grad_unit__recv_prev__msg = recv_prev__msg;
  assign recv_prev__rdy = grad_unit__recv_prev__rdy;
  assign grad_unit__recv_prev__val = recv_prev__val;
  assign hs_core__recv_grads__msg = grad_unit__send_grad__msg;
  assign grad_unit__send_grad__rdy = hs_core__recv_grads__rdy;
  assign hs_core__recv_grads__val = grad_unit__send_grad__val;
  assign hs_core__recv_uv__msg = recv_init_uv__msg;
  assign recv_init_uv__rdy = hs_core__recv_uv__rdy;
  assign hs_core__recv_uv__val = recv_init_uv__val;
  assign send_uv__msg = hs_core__send_uv__msg;
  assign hs_core__send_uv__rdy = send_uv__rdy;
  assign send_uv__val = hs_core__send_uv__val;

endmodule


// PyMTL Component HSCore Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\hs_core.py

module HSCore__alpha_5
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [47:0] recv_grads__msg  ,
  output logic [0:0] recv_grads__rdy  ,
  input logic [0:0] recv_grads__val  ,
  input logic [63:0] recv_uv__msg  ,
  output logic [0:0] recv_uv__rdy  ,
  input logic [0:0] recv_uv__val  ,
  output logic [63:0] send_uv__msg  ,
  input logic [0:0] send_uv__rdy  ,
  output logic [0:0] send_uv__val  
);
  localparam logic [3:0] __const__FP_SHIFT_at_math_logic  = 4'd12;
  logic [31:0] ALPHA_SQ;
  logic [31:0] dbg_denom;
  logic [31:0] denom_safe;
  logic [15:0] __tmpvar__math_logic_raw_ix;
  logic [15:0] __tmpvar__math_logic_raw_iy;
  logic [15:0] __tmpvar__math_logic_raw_it;
  logic [31:0] __tmpvar__math_logic_raw_u_init;
  logic [31:0] __tmpvar__math_logic_raw_v_init;
  logic [31:0] __tmpvar__math_logic_ix;
  logic [31:0] __tmpvar__math_logic_iy;
  logic [31:0] __tmpvar__math_logic_it;
  logic [31:0] __tmpvar__math_logic_u_init;
  logic [31:0] __tmpvar__math_logic_v_init;
  logic [31:0] __tmpvar__math_logic_denom;
  logic [31:0] __tmpvar__math_logic_term_it;
  logic [31:0] __tmpvar__math_logic_data_term;
  logic [31:0] __tmpvar__math_logic_num_u;
  logic [31:0] __tmpvar__math_logic_update_u;
  logic [31:0] __tmpvar__math_logic_num_v;
  logic [31:0] __tmpvar__math_logic_update_v;
  logic [31:0] __tmpvar__math_logic_u_new;
  logic [31:0] __tmpvar__math_logic_v_new;

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\hs_core.py:20
  // @update
  // def math_logic():
  //     s.recv_grads.rdy @= s.send_uv.rdy
  //     s.recv_uv.rdy    @= s.send_uv.rdy
  //     
  //     # 1. Extragere Valori Raw (Bits)
  //     raw_ix = s.recv_grads.msg[0:16]
  //     raw_iy = s.recv_grads.msg[16:32]
  //     raw_it = s.recv_grads.msg[32:48]
  //     
  //     raw_u_init = s.recv_uv.msg[0:32]
  //     raw_v_init = s.recv_uv.msg[32:64]
  //     
  //     # 2. Extensie de Semn
  //     ix = sext(raw_ix, 32)
  //     iy = sext(raw_iy, 32)
  //     it = sext(raw_it, 32)
  //     
  //     u_init = raw_u_init
  //     v_init = raw_v_init
  //     
  //     # 3. Calcule Matematice
  //     denom = s.ALPHA_SQ + (ix * ix) + (iy * iy)
  //     
  //     # Protectie la impartire prin zero (Hardware Mux Logic)
  //     if denom == 0: 
  //         s.denom_safe @= 1
  //     else:
  //         s.denom_safe @= denom
  //     
  //     s.dbg_denom @= s.denom_safe
  //     
  //     # Data Term
  //     term_it = it << FP_SHIFT
  //     data_term = (ix * u_init) + (iy * v_init) + term_it
  //     
  //     # Calcul Update
  //     # Folosim denom_safe care este Wire acum
  //     num_u = ix * data_term
  //     update_u = num_u / s.denom_safe
  //     
  //     num_v = iy * data_term
  //     update_v = num_v / s.denom_safe
  //     
  //     # Rezultat Final
  //     u_new = u_init - update_u
  //     v_new = v_init - update_v
  //     
  //     # Impachetare
  //     s.send_uv.msg @= concat( v_new, u_new )
  //     s.send_uv.val @= s.recv_grads.val & s.recv_uv.val
  
  always_comb begin : math_logic
    recv_grads__rdy = send_uv__rdy;
    recv_uv__rdy = send_uv__rdy;
    __tmpvar__math_logic_raw_ix = recv_grads__msg[6'd15:6'd0];
    __tmpvar__math_logic_raw_iy = recv_grads__msg[6'd31:6'd16];
    __tmpvar__math_logic_raw_it = recv_grads__msg[6'd47:6'd32];
    __tmpvar__math_logic_raw_u_init = recv_uv__msg[6'd31:6'd0];
    __tmpvar__math_logic_raw_v_init = recv_uv__msg[6'd63:6'd32];
    __tmpvar__math_logic_ix = { { 16 { __tmpvar__math_logic_raw_ix[15] } }, __tmpvar__math_logic_raw_ix };
    __tmpvar__math_logic_iy = { { 16 { __tmpvar__math_logic_raw_iy[15] } }, __tmpvar__math_logic_raw_iy };
    __tmpvar__math_logic_it = { { 16 { __tmpvar__math_logic_raw_it[15] } }, __tmpvar__math_logic_raw_it };
    __tmpvar__math_logic_u_init = __tmpvar__math_logic_raw_u_init;
    __tmpvar__math_logic_v_init = __tmpvar__math_logic_raw_v_init;
    __tmpvar__math_logic_denom = ( ALPHA_SQ + ( __tmpvar__math_logic_ix * __tmpvar__math_logic_ix ) ) + ( __tmpvar__math_logic_iy * __tmpvar__math_logic_iy );
    if ( __tmpvar__math_logic_denom == 32'd0 ) begin
      denom_safe = 32'd1;
    end
    else
      denom_safe = __tmpvar__math_logic_denom;
    dbg_denom = denom_safe;
    __tmpvar__math_logic_term_it = __tmpvar__math_logic_it << 4'( __const__FP_SHIFT_at_math_logic );
    __tmpvar__math_logic_data_term = ( ( __tmpvar__math_logic_ix * __tmpvar__math_logic_u_init ) + ( __tmpvar__math_logic_iy * __tmpvar__math_logic_v_init ) ) + __tmpvar__math_logic_term_it;
    __tmpvar__math_logic_num_u = __tmpvar__math_logic_ix * __tmpvar__math_logic_data_term;
    __tmpvar__math_logic_update_u = __tmpvar__math_logic_num_u / denom_safe;
    __tmpvar__math_logic_num_v = __tmpvar__math_logic_iy * __tmpvar__math_logic_data_term;
    __tmpvar__math_logic_update_v = __tmpvar__math_logic_num_v / denom_safe;
    __tmpvar__math_logic_u_new = __tmpvar__math_logic_u_init - __tmpvar__math_logic_update_u;
    __tmpvar__math_logic_v_new = __tmpvar__math_logic_v_init - __tmpvar__math_logic_update_v;
    send_uv__msg = { __tmpvar__math_logic_v_new, __tmpvar__math_logic_u_new };
    send_uv__val = recv_grads__val & recv_uv__val;
  end

  assign ALPHA_SQ = 32'd25;

endmodule


// PyMTL Component LineBuffer Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\line_buffer.py

module LineBuffer__data_width_8__img_width_64
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [7:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output logic [23:0] send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  logic [31:0] count;
  logic [7:0] line_mem_1 [0:63];
  logic [7:0] line_mem_2 [0:63];
  logic [5:0] ptr;
  logic [7:0] val_popped;
  logic [5:0] __tmpvar__sequential_logic_idx;
  logic [5:0] __tmpvar__output_logic_r_idx;
  logic [7:0] __tmpvar__output_logic_p0;
  logic [7:0] __tmpvar__output_logic_p1;
  logic [7:0] __tmpvar__output_logic_p2;

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\line_buffer.py:54
  // @update
  // def output_logic():
  //     s.recv.rdy @= s.send.rdy
  //     
  //     # CALCUL INDEX CITIRE
  //     # FIX: Eliminam int()
  //     # Logica de wrap-around pentru pointer circular
  //     r_idx = s.ptr
  //     if s.ptr == 0:
  //         r_idx = s.IMG_WIDTH - 1
  //     else:
  //         r_idx = s.ptr - 1
  //     
  //     # CONSTRUIRE FEREASTRA
  //     p0 = s.recv.msg
  //     p1 = s.line_mem_2[r_idx]
  //     p2 = s.val_popped
  //     
  //     s.send.msg @= concat( p2, p1, p0 )
  //     
  //     # Valid dupa ce avem 2 linii pline
  //     # Folosim & in loc de and
  //     s.send.val @= s.recv.val & (s.count >= (s.IMG_WIDTH * 2))
  
  always_comb begin : output_logic
    recv__rdy = send__rdy;
    __tmpvar__output_logic_r_idx = ptr;
    if ( ptr == 6'd0 ) begin
      __tmpvar__output_logic_r_idx = 7'd64 - 7'd1;
    end
    else
      __tmpvar__output_logic_r_idx = ptr - 6'd1;
    __tmpvar__output_logic_p0 = recv__msg;
    __tmpvar__output_logic_p1 = line_mem_2[__tmpvar__output_logic_r_idx];
    __tmpvar__output_logic_p2 = val_popped;
    send__msg = { __tmpvar__output_logic_p2, __tmpvar__output_logic_p1, __tmpvar__output_logic_p0 };
    send__val = recv__val & ( count >= ( 32'd64 * 32'd2 ) );
  end

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\line_buffer.py:28
  // @update_ff
  // def sequential_logic():
  //     if s.reset:
  //         s.ptr <<= 0
  //         s.count <<= 0
  //         s.val_popped <<= 0
  //     # FIX: Folosim & in loc de and
  //     elif s.recv.val & s.send.rdy:
  //         # FIX: Eliminam int(). Folosim semnalul direct.
  //         idx = s.ptr
  //         
  //         # 1. SALVAM VECHILE VALORI
  //         s.val_popped <<= s.line_mem_2[idx]
  //         
  //         # 2. SHIFTAM DATELE
  //         s.line_mem_2[idx] <<= s.line_mem_1[idx]
  //         s.line_mem_1[idx] <<= s.recv.msg
  //         
  //         # 3. ACTUALIZAM POINTERII
  //         if s.ptr == s.IMG_WIDTH - 1:
  //             s.ptr <<= 0
  //         else:
  //             s.ptr <<= s.ptr + 1
  //         
  //         s.count <<= s.count + 1
  
  always_ff @(posedge clk) begin : sequential_logic
    if ( reset ) begin
      ptr <= 6'd0;
      count <= 32'd0;
      val_popped <= 8'd0;
    end
    else if ( recv__val & send__rdy ) begin
      __tmpvar__sequential_logic_idx = ptr;
      val_popped <= line_mem_2[__tmpvar__sequential_logic_idx];
      line_mem_2[__tmpvar__sequential_logic_idx] <= line_mem_1[__tmpvar__sequential_logic_idx];
      line_mem_1[__tmpvar__sequential_logic_idx] <= recv__msg;
      if ( ptr == ( 6'd64 - 6'd1 ) ) begin
        ptr <= 6'd0;
      end
      else
        ptr <= ptr + 6'd1;
      count <= count + 32'd1;
    end
  end

endmodule


// PyMTL Component OpticalFlowTop Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\optical_flow_top.py

module OpticalFlowTop__img_width_64__alpha_5
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [7:0] recv_curr__msg  ,
  output logic [0:0] recv_curr__rdy  ,
  input logic [0:0] recv_curr__val  ,
  input logic [63:0] recv_init_uv__msg  ,
  output logic [0:0] recv_init_uv__rdy  ,
  input logic [0:0] recv_init_uv__val  ,
  input logic [7:0] recv_prev__msg  ,
  output logic [0:0] recv_prev__rdy  ,
  input logic [0:0] recv_prev__val  ,
  output logic [63:0] send_uv__msg  ,
  input logic [0:0] send_uv__rdy  ,
  output logic [0:0] send_uv__val  
);
  //-------------------------------------------------------------
  // Component grad_unit
  //-------------------------------------------------------------

  logic [0:0] grad_unit__clk;
  logic [0:0] grad_unit__reset;
  logic [23:0] grad_unit__recv_col__msg;
  logic [0:0] grad_unit__recv_col__rdy;
  logic [0:0] grad_unit__recv_col__val;
  logic [7:0] grad_unit__recv_prev__msg;
  logic [0:0] grad_unit__recv_prev__rdy;
  logic [0:0] grad_unit__recv_prev__val;
  logic [47:0] grad_unit__send_grad__msg;
  logic [0:0] grad_unit__send_grad__rdy;
  logic [0:0] grad_unit__send_grad__val;

  GradientUnit_noparam grad_unit
  (
    .clk( grad_unit__clk ),
    .reset( grad_unit__reset ),
    .recv_col__msg( grad_unit__recv_col__msg ),
    .recv_col__rdy( grad_unit__recv_col__rdy ),
    .recv_col__val( grad_unit__recv_col__val ),
    .recv_prev__msg( grad_unit__recv_prev__msg ),
    .recv_prev__rdy( grad_unit__recv_prev__rdy ),
    .recv_prev__val( grad_unit__recv_prev__val ),
    .send_grad__msg( grad_unit__send_grad__msg ),
    .send_grad__rdy( grad_unit__send_grad__rdy ),
    .send_grad__val( grad_unit__send_grad__val )
  );

  //-------------------------------------------------------------
  // End of component grad_unit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component hs_core
  //-------------------------------------------------------------

  logic [0:0] hs_core__clk;
  logic [0:0] hs_core__reset;
  logic [47:0] hs_core__recv_grads__msg;
  logic [0:0] hs_core__recv_grads__rdy;
  logic [0:0] hs_core__recv_grads__val;
  logic [63:0] hs_core__recv_uv__msg;
  logic [0:0] hs_core__recv_uv__rdy;
  logic [0:0] hs_core__recv_uv__val;
  logic [63:0] hs_core__send_uv__msg;
  logic [0:0] hs_core__send_uv__rdy;
  logic [0:0] hs_core__send_uv__val;

  HSCore__alpha_5 hs_core
  (
    .clk( hs_core__clk ),
    .reset( hs_core__reset ),
    .recv_grads__msg( hs_core__recv_grads__msg ),
    .recv_grads__rdy( hs_core__recv_grads__rdy ),
    .recv_grads__val( hs_core__recv_grads__val ),
    .recv_uv__msg( hs_core__recv_uv__msg ),
    .recv_uv__rdy( hs_core__recv_uv__rdy ),
    .recv_uv__val( hs_core__recv_uv__val ),
    .send_uv__msg( hs_core__send_uv__msg ),
    .send_uv__rdy( hs_core__send_uv__rdy ),
    .send_uv__val( hs_core__send_uv__val )
  );

  //-------------------------------------------------------------
  // End of component hs_core
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component line_buffer
  //-------------------------------------------------------------

  logic [0:0] line_buffer__clk;
  logic [0:0] line_buffer__reset;
  logic [7:0] line_buffer__recv__msg;
  logic [0:0] line_buffer__recv__rdy;
  logic [0:0] line_buffer__recv__val;
  logic [23:0] line_buffer__send__msg;
  logic [0:0] line_buffer__send__rdy;
  logic [0:0] line_buffer__send__val;

  LineBuffer__data_width_8__img_width_64 line_buffer
  (
    .clk( line_buffer__clk ),
    .reset( line_buffer__reset ),
    .recv__msg( line_buffer__recv__msg ),
    .recv__rdy( line_buffer__recv__rdy ),
    .recv__val( line_buffer__recv__val ),
    .send__msg( line_buffer__send__msg ),
    .send__rdy( line_buffer__send__rdy ),
    .send__val( line_buffer__send__val )
  );

  //-------------------------------------------------------------
  // End of component line_buffer
  //-------------------------------------------------------------

  assign line_buffer__clk = clk;
  assign line_buffer__reset = reset;
  assign grad_unit__clk = clk;
  assign grad_unit__reset = reset;
  assign hs_core__clk = clk;
  assign hs_core__reset = reset;
  assign line_buffer__recv__msg = recv_curr__msg;
  assign recv_curr__rdy = line_buffer__recv__rdy;
  assign line_buffer__recv__val = recv_curr__val;
  assign grad_unit__recv_col__msg = line_buffer__send__msg;
  assign line_buffer__send__rdy = grad_unit__recv_col__rdy;
  assign grad_unit__recv_col__val = line_buffer__send__val;
  assign grad_unit__recv_prev__msg = recv_prev__msg;
  assign recv_prev__rdy = grad_unit__recv_prev__rdy;
  assign grad_unit__recv_prev__val = recv_prev__val;
  assign hs_core__recv_grads__msg = grad_unit__send_grad__msg;
  assign grad_unit__send_grad__rdy = hs_core__recv_grads__rdy;
  assign hs_core__recv_grads__val = grad_unit__send_grad__val;
  assign hs_core__recv_uv__msg = recv_init_uv__msg;
  assign recv_init_uv__rdy = hs_core__recv_uv__rdy;
  assign hs_core__recv_uv__val = recv_init_uv__val;
  assign send_uv__msg = hs_core__send_uv__msg;
  assign hs_core__send_uv__rdy = send_uv__rdy;
  assign send_uv__val = hs_core__send_uv__val;

endmodule


// PyMTL Component Upsampler Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\upsampler.py

module Upsampler_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [63:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  input logic [0:0] recv__val  ,
  output logic [63:0] send__msg  ,
  input logic [0:0] send__rdy  ,
  output logic [0:0] send__val  
);
  logic [31:0] __tmpvar__comb_logic_u_coarse;
  logic [31:0] __tmpvar__comb_logic_v_coarse;
  logic [31:0] __tmpvar__comb_logic_u_scaled;
  logic [31:0] __tmpvar__comb_logic_v_scaled;

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\upsampler.py:10
  // @update
  // def comb_logic():
  //     s.recv.rdy @= s.send.rdy
  //     
  //     u_coarse = s.recv.msg[0:32]
  //     v_coarse = s.recv.msg[32:64]
  //     
  //     u_scaled = u_coarse << 1
  //     v_scaled = v_coarse << 1
  //     
  //     s.send.msg @= concat( v_scaled, u_scaled )
  //     s.send.val @= s.recv.val
  
  always_comb begin : comb_logic
    recv__rdy = send__rdy;
    __tmpvar__comb_logic_u_coarse = recv__msg[6'd31:6'd0];
    __tmpvar__comb_logic_v_coarse = recv__msg[6'd63:6'd32];
    __tmpvar__comb_logic_u_scaled = __tmpvar__comb_logic_u_coarse << 1'd1;
    __tmpvar__comb_logic_v_scaled = __tmpvar__comb_logic_v_coarse << 1'd1;
    send__msg = { __tmpvar__comb_logic_v_scaled, __tmpvar__comb_logic_u_scaled };
    send__val = recv__val;
  end

endmodule


// PyMTL Component PyramidalOpticalFlow Definition
// At C:\Users\CezarSefu\Desktop\prroiectac2\src\pyramidal_of_top.py

module PyramidalOpticalFlow__width_64
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [7:0] recv_curr__msg  ,
  output logic [0:0] recv_curr__rdy  ,
  input logic [0:0] recv_curr__val  ,
  input logic [7:0] recv_prev__msg  ,
  output logic [0:0] recv_prev__rdy  ,
  input logic [0:0] recv_prev__val  ,
  output logic [63:0] send_uv__msg  ,
  input logic [0:0] send_uv__rdy  ,
  output logic [0:0] send_uv__val  
);
  //-------------------------------------------------------------
  // Component down_curr
  //-------------------------------------------------------------

  logic [0:0] down_curr__clk;
  logic [0:0] down_curr__reset;
  logic [7:0] down_curr__recv__msg;
  logic [0:0] down_curr__recv__rdy;
  logic [0:0] down_curr__recv__val;
  logic [7:0] down_curr__send__msg;
  logic [0:0] down_curr__send__rdy;
  logic [0:0] down_curr__send__val;

  Downsampler__img_width_64 down_curr
  (
    .clk( down_curr__clk ),
    .reset( down_curr__reset ),
    .recv__msg( down_curr__recv__msg ),
    .recv__rdy( down_curr__recv__rdy ),
    .recv__val( down_curr__recv__val ),
    .send__msg( down_curr__send__msg ),
    .send__rdy( down_curr__send__rdy ),
    .send__val( down_curr__send__val )
  );

  //-------------------------------------------------------------
  // End of component down_curr
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component down_prev
  //-------------------------------------------------------------

  logic [0:0] down_prev__clk;
  logic [0:0] down_prev__reset;
  logic [7:0] down_prev__recv__msg;
  logic [0:0] down_prev__recv__rdy;
  logic [0:0] down_prev__recv__val;
  logic [7:0] down_prev__send__msg;
  logic [0:0] down_prev__send__rdy;
  logic [0:0] down_prev__send__val;

  Downsampler__img_width_64 down_prev
  (
    .clk( down_prev__clk ),
    .reset( down_prev__reset ),
    .recv__msg( down_prev__recv__msg ),
    .recv__rdy( down_prev__recv__rdy ),
    .recv__val( down_prev__recv__val ),
    .send__msg( down_prev__send__msg ),
    .send__rdy( down_prev__send__rdy ),
    .send__val( down_prev__send__val )
  );

  //-------------------------------------------------------------
  // End of component down_prev
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component of_coarse
  //-------------------------------------------------------------

  logic [0:0] of_coarse__clk;
  logic [0:0] of_coarse__reset;
  logic [7:0] of_coarse__recv_curr__msg;
  logic [0:0] of_coarse__recv_curr__rdy;
  logic [0:0] of_coarse__recv_curr__val;
  logic [63:0] of_coarse__recv_init_uv__msg;
  logic [0:0] of_coarse__recv_init_uv__rdy;
  logic [0:0] of_coarse__recv_init_uv__val;
  logic [7:0] of_coarse__recv_prev__msg;
  logic [0:0] of_coarse__recv_prev__rdy;
  logic [0:0] of_coarse__recv_prev__val;
  logic [63:0] of_coarse__send_uv__msg;
  logic [0:0] of_coarse__send_uv__rdy;
  logic [0:0] of_coarse__send_uv__val;

  OpticalFlowTop__img_width_32__alpha_20 of_coarse
  (
    .clk( of_coarse__clk ),
    .reset( of_coarse__reset ),
    .recv_curr__msg( of_coarse__recv_curr__msg ),
    .recv_curr__rdy( of_coarse__recv_curr__rdy ),
    .recv_curr__val( of_coarse__recv_curr__val ),
    .recv_init_uv__msg( of_coarse__recv_init_uv__msg ),
    .recv_init_uv__rdy( of_coarse__recv_init_uv__rdy ),
    .recv_init_uv__val( of_coarse__recv_init_uv__val ),
    .recv_prev__msg( of_coarse__recv_prev__msg ),
    .recv_prev__rdy( of_coarse__recv_prev__rdy ),
    .recv_prev__val( of_coarse__recv_prev__val ),
    .send_uv__msg( of_coarse__send_uv__msg ),
    .send_uv__rdy( of_coarse__send_uv__rdy ),
    .send_uv__val( of_coarse__send_uv__val )
  );

  //-------------------------------------------------------------
  // End of component of_coarse
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component of_fine
  //-------------------------------------------------------------

  logic [0:0] of_fine__clk;
  logic [0:0] of_fine__reset;
  logic [7:0] of_fine__recv_curr__msg;
  logic [0:0] of_fine__recv_curr__rdy;
  logic [0:0] of_fine__recv_curr__val;
  logic [63:0] of_fine__recv_init_uv__msg;
  logic [0:0] of_fine__recv_init_uv__rdy;
  logic [0:0] of_fine__recv_init_uv__val;
  logic [7:0] of_fine__recv_prev__msg;
  logic [0:0] of_fine__recv_prev__rdy;
  logic [0:0] of_fine__recv_prev__val;
  logic [63:0] of_fine__send_uv__msg;
  logic [0:0] of_fine__send_uv__rdy;
  logic [0:0] of_fine__send_uv__val;

  OpticalFlowTop__img_width_64__alpha_5 of_fine
  (
    .clk( of_fine__clk ),
    .reset( of_fine__reset ),
    .recv_curr__msg( of_fine__recv_curr__msg ),
    .recv_curr__rdy( of_fine__recv_curr__rdy ),
    .recv_curr__val( of_fine__recv_curr__val ),
    .recv_init_uv__msg( of_fine__recv_init_uv__msg ),
    .recv_init_uv__rdy( of_fine__recv_init_uv__rdy ),
    .recv_init_uv__val( of_fine__recv_init_uv__val ),
    .recv_prev__msg( of_fine__recv_prev__msg ),
    .recv_prev__rdy( of_fine__recv_prev__rdy ),
    .recv_prev__val( of_fine__recv_prev__val ),
    .send_uv__msg( of_fine__send_uv__msg ),
    .send_uv__rdy( of_fine__send_uv__rdy ),
    .send_uv__val( of_fine__send_uv__val )
  );

  //-------------------------------------------------------------
  // End of component of_fine
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component upsampler
  //-------------------------------------------------------------

  logic [0:0] upsampler__clk;
  logic [0:0] upsampler__reset;
  logic [63:0] upsampler__recv__msg;
  logic [0:0] upsampler__recv__rdy;
  logic [0:0] upsampler__recv__val;
  logic [63:0] upsampler__send__msg;
  logic [0:0] upsampler__send__rdy;
  logic [0:0] upsampler__send__val;

  Upsampler_noparam upsampler
  (
    .clk( upsampler__clk ),
    .reset( upsampler__reset ),
    .recv__msg( upsampler__recv__msg ),
    .recv__rdy( upsampler__recv__rdy ),
    .recv__val( upsampler__recv__val ),
    .send__msg( upsampler__send__msg ),
    .send__rdy( upsampler__send__rdy ),
    .send__val( upsampler__send__val )
  );

  //-------------------------------------------------------------
  // End of component upsampler
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\pyramidal_of_top.py:63
  // @update
  // def coarse_init_logic():
  //     s.of_coarse.recv_init_uv.msg @= 0
  //     s.of_coarse.recv_init_uv.val @= 1
  
  always_comb begin : coarse_init_logic
    of_coarse__recv_init_uv__msg = 64'd0;
    of_coarse__recv_init_uv__val = 1'd1;
  end

  // PyMTL Update Block Source
  // At C:\Users\CezarSefu\Desktop\prroiectac2\src\pyramidal_of_top.py:35
  // @update
  // def input_splitter_logic():
  //     # 1. Pixel Curent
  //     s.down_curr.recv.msg @= s.recv_curr.msg
  //     s.down_curr.recv.val @= s.recv_curr.val
  //     
  //     s.of_fine.recv_curr.msg @= s.recv_curr.msg
  //     s.of_fine.recv_curr.val @= s.recv_curr.val
  //     
  //     # Ready global este AND intre Ready Downsampler si Ready Fine
  //     s.recv_curr.rdy @= s.down_curr.recv.rdy & s.of_fine.recv_curr.rdy
  //     
  //     # 2. Pixel Anterior
  //     s.down_prev.recv.msg @= s.recv_prev.msg
  //     s.down_prev.recv.val @= s.recv_prev.val
  //     
  //     s.of_fine.recv_prev.msg @= s.recv_prev.msg
  //     s.of_fine.recv_prev.val @= s.recv_prev.val
  //     
  //     s.recv_prev.rdy @= s.down_prev.recv.rdy & s.of_fine.recv_prev.rdy
  
  always_comb begin : input_splitter_logic
    down_curr__recv__msg = recv_curr__msg;
    down_curr__recv__val = recv_curr__val;
    of_fine__recv_curr__msg = recv_curr__msg;
    of_fine__recv_curr__val = recv_curr__val;
    recv_curr__rdy = down_curr__recv__rdy & of_fine__recv_curr__rdy;
    down_prev__recv__msg = recv_prev__msg;
    down_prev__recv__val = recv_prev__val;
    of_fine__recv_prev__msg = recv_prev__msg;
    of_fine__recv_prev__val = recv_prev__val;
    recv_prev__rdy = down_prev__recv__rdy & of_fine__recv_prev__rdy;
  end

  assign down_curr__clk = clk;
  assign down_curr__reset = reset;
  assign down_prev__clk = clk;
  assign down_prev__reset = reset;
  assign of_coarse__clk = clk;
  assign of_coarse__reset = reset;
  assign upsampler__clk = clk;
  assign upsampler__reset = reset;
  assign of_fine__clk = clk;
  assign of_fine__reset = reset;
  assign of_coarse__recv_curr__msg = down_curr__send__msg;
  assign down_curr__send__rdy = of_coarse__recv_curr__rdy;
  assign of_coarse__recv_curr__val = down_curr__send__val;
  assign of_coarse__recv_prev__msg = down_prev__send__msg;
  assign down_prev__send__rdy = of_coarse__recv_prev__rdy;
  assign of_coarse__recv_prev__val = down_prev__send__val;
  assign upsampler__recv__msg = of_coarse__send_uv__msg;
  assign of_coarse__send_uv__rdy = upsampler__recv__rdy;
  assign upsampler__recv__val = of_coarse__send_uv__val;
  assign of_fine__recv_init_uv__msg = upsampler__send__msg;
  assign upsampler__send__rdy = of_fine__recv_init_uv__rdy;
  assign of_fine__recv_init_uv__val = upsampler__send__val;
  assign send_uv__msg = of_fine__send_uv__msg;
  assign of_fine__send_uv__rdy = send_uv__rdy;
  assign send_uv__val = of_fine__send_uv__val;

endmodule
